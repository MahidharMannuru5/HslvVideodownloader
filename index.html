<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HLS Recorder (WebM, auto-save)</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; padding:20px; }
  .wrap { max-width: 960px; margin: 0 auto; display: grid; gap: 14px; }
  .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  input[type=url]{ flex:1 1 420px; padding:10px; border-radius:10px; border:1px solid #8884; }
  label { display:flex; align-items:center; gap:6px; font-size:.95rem; }
  button { padding:10px 14px; border:0; border-radius:12px; cursor:pointer; }
  button.primary { background:#2563eb; color:#fff; }
  button.ghost { background:transparent; border:1px solid #8884; }
  video { width:100%; aspect-ratio:16/9; background:#000; border-radius:16px; }
  .pill { padding:6px 10px; border-radius:999px; background:#8882; font-variant-numeric: tabular-nums; }
  .muted { opacity:.75; }
  #log { white-space:pre-wrap; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0000000a; padding:12px; border-radius:12px; max-height:260px; overflow:auto; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Record HLS from “now” (WebM, auto-save)</h1>

  <div class="row">
    <input id="m3u8" type="url" placeholder="Paste your .m3u8 URL" />
    <button id="play" class="primary">Play</button>
  </div>

  <div class="row">
    <label><input id="optAutoStart" type="checkbox" checked /> Auto-start recording after Play</label>
    <label><input id="optAutoEnd" type="checkbox" checked /> Auto-stop & save when stream ends</label>
  </div>
  <div class="row">
    <label><input id="optAutoLeave" type="checkbox" checked /> Auto-save on background/leave (best-effort)</label>
    <label><input id="optContSave" type="checkbox" /> Continuous save to file (Chrome/Edge/Android)</label>
  </div>

  <video id="video" controls playsinline></video>

  <div class="row">
    <button id="startMR" class="primary">Start Recording (WebM)</button>
    <button id="stopMR" class="ghost" disabled>Stop & Save (WebM)</button>
    <span id="status" class="pill">idle</span>
  </div>

  <details>
    <summary>Diagnostics & log</summary>
    <div id="log"></div>
  </details>

  <p class="muted">
    Works on Android/desktop Chrome, Edge, Firefox. iOS Safari can play HLS but cannot be recorded with MediaRecorder.
    GitHub Pages is static (no Python). If you ever need MP4/no-encode capture, you’d need a small server.
  </p>
</div>

<!-- hls.js for playback only -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.8/dist/hls.min.js"></script>
<script>
const $ = s => document.querySelector(s);
const video = $("#video");
const urlInput = $("#m3u8");
const playBtn = $("#play");
const startBtn = $("#startMR");
const stopBtn = $("#stopMR");
const statusEl = $("#status");
const logEl = $("#log");

const optAutoStart = $("#optAutoStart");
const optAutoEnd   = $("#optAutoEnd");
const optAutoLeave = $("#optAutoLeave");
const optContSave  = $("#optContSave");

let hls = null;

// MediaRecorder state
let mr = null;
let mrChunks = [];
let bytes = 0;
let mime = "video/webm";
let recording = false;
let autoStarted = false;

// Continuous Save state (File System Access API)
let writer = null; // FileSystemWritableFileStream

function log(...args){
  const t = new Date().toISOString().slice(11,19);
  const line = `[${t}] ${args.join(" ")}\n`;
  logEl.textContent += line;
  logEl.scrollTop = logEl.scrollHeight;
  console.log(...args);
}
function setStatus(t){ statusEl.textContent = t; }

function isiOS(){ return /iP(hone|ad|od)/.test(navigator.userAgent); }
function isSafari(){ return /^((?!chrome|android).)*safari/i.test(navigator.userAgent); }

// File download helper (for non-continuous mode)
function downloadBlob(parts, type, name){
  const blob = new Blob(parts, { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = name;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 10_000);
}

async function setupHlsAndPlay(src){
  // Safari/iOS (native) can play but MediaRecorder won’t record
  if ((isiOS() && isSafari()) || (video.canPlayType("application/vnd.apple.mpegurl") && !Hls.isSupported())){
    log("Native HLS path detected (Safari/iOS) — MediaRecorder not available.");
    video.src = src;
    await video.play().catch(()=>{});
    return;
  }
  if (hls) { hls.destroy(); hls = null; }
  hls = new Hls({ enableWorker: true });
  hls.attachMedia(video);
  hls.on(Hls.Events.MEDIA_ATTACHED, () => hls.loadSource(src));
  hls.on(Hls.Events.MANIFEST_PARSED, () => {
    video.play().catch(()=>{});
    log("HLS manifest parsed.");
  });
  hls.on(Hls.Events.ERROR, (_, data) => {
    log("hls.js error:", data?.details || data?.type || "unknown");
    if (data?.fatal && optAutoEnd.checked) {
      log("Fatal stream error — auto-stopping recording.");
      safeStopRecording();
    }
  });
}

async function startRecording() {
  if (!video.captureStream) { alert("MediaRecorder not supported here."); return; }
  if (recording) return;

  const stream = video.captureStream();
  mime = MediaRecorder.isTypeSupported("video/webm;codecs=vp9") ? "video/webm;codecs=vp9"
       : MediaRecorder.isTypeSupported("video/webm;codecs=vp8") ? "video/webm;codecs=vp8"
       : "video/webm";

  mrChunks = [];
  bytes = 0;

  // If user opted for continuous save, open a file once (requires user gesture)
  if (optContSave.checked && 'showSaveFilePicker' in window) {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: `recording-${new Date().toISOString().replace(/[:.]/g,"-")}.webm`,
        types: [{ description: "WebM Video", accept: { "video/webm": [".webm"] } }]
      });
      writer = await handle.createWritable();
      log("Continuous save enabled: writing chunks directly to file.");
    } catch (e) {
      log("File picker canceled or API not available:", e.message || e);
      writer = null;
      optContSave.checked = false;
    }
  } else {
    writer = null;
  }

  mr = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 4_000_000 });

  mr.ondataavailable = async (e) => {
    if (!e.data || !e.data.size) return;
    bytes += e.data.size;
    if (writer) {
      try { await writer.write(e.data); }
      catch (err) { log("Write error:", err.message || err); }
    } else {
      mrChunks.push(e.data);
    }
    setStatus(`recording… ${(bytes/1024/1024).toFixed(2)} MB`);
  };

  mr.onstop = async () => {
    if (writer) {
      try { await writer.close(); log("File closed — saved to disk."); }
      catch (e) { log("Error closing file:", e.message || e); }
      writer = null;
      setStatus("saved (file)");
      return;
    }
    if (mrChunks.length) {
      downloadBlob(mrChunks, mime, `recording-${new Date().toISOString().replace(/[:.]/g,"-")}.webm`);
      setStatus("saved (WebM)");
    } else {
      setStatus("nothing recorded");
    }
  };

  mr.start(1000); // collect chunks every second
  recording = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  setStatus("recording…");
  log("MediaRecorder started with", mime);
}

function stopRecording() {
  if (mr && recording && mr.state !== "inactive") {
    try { mr.stop(); } catch {}
  }
  recording = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
}

function safeStopRecording() {
  if (!recording) return;
  try { mr.requestData && mr.requestData(); } catch {}
  stopRecording();
}

// --- UI wiring ---
playBtn.addEventListener("click", async () => {
  const src = urlInput.value.trim();
  if (!src) return alert("Paste a .m3u8 URL");
  autoStarted = false;
  await setupHlsAndPlay(src);
});

// Auto-start recording when video actually starts playing
video.addEventListener("playing", () => {
  if (optAutoStart.checked && !autoStarted) {
    autoStarted = true;
    startRecording();
  }
});

// Auto-stop & save when stream ends
video.addEventListener("ended", () => {
  log("Video ended.");
  if (optAutoEnd.checked) safeStopRecording();
});

// Optional: if playback errors out
video.addEventListener("error", () => {
  log("Video element error.");
  if (optAutoEnd.checked) safeStopRecording();
});

// Save when user leaves / app goes to background (best-effort)
if (optAutoLeave) {
  const leaveHandler = () => { if (optAutoLeave.checked) safeStopRecording(); };
  window.addEventListener("pagehide", leaveHandler);
  window.addEventListener("beforeunload", leaveHandler);
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden" && optAutoLeave.checked) safeStopRecording();
  });
}

startBtn.addEventListener("click", () => startRecording());
stopBtn.addEventListener("click", () => safeStopRecording());

// Helpful: allow ?u=<m3u8> to auto-load
const qp = new URLSearchParams(location.search);
if (qp.get("u")) { urlInput.value = qp.get("u"); playBtn.click(); }
</script>
</body>
</html>
